// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../ev-girs
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsAnnotationType")]
pub enum AnnotationType {
    #[doc(alias = "PPS_ANNOTATION_TYPE_UNKNOWN")]
    Unknown,
    #[doc(alias = "PPS_ANNOTATION_TYPE_TEXT")]
    Text,
    #[doc(alias = "PPS_ANNOTATION_TYPE_ATTACHMENT")]
    Attachment,
    #[doc(alias = "PPS_ANNOTATION_TYPE_TEXT_MARKUP")]
    TextMarkup,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AnnotationType {
    type GlibType = ffi::PpsAnnotationType;

    #[inline]
    fn into_glib(self) -> ffi::PpsAnnotationType {
        match self {
            Self::Unknown => ffi::PPS_ANNOTATION_TYPE_UNKNOWN,
            Self::Text => ffi::PPS_ANNOTATION_TYPE_TEXT,
            Self::Attachment => ffi::PPS_ANNOTATION_TYPE_ATTACHMENT,
            Self::TextMarkup => ffi::PPS_ANNOTATION_TYPE_TEXT_MARKUP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsAnnotationType> for AnnotationType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsAnnotationType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_ANNOTATION_TYPE_UNKNOWN => Self::Unknown,
            ffi::PPS_ANNOTATION_TYPE_TEXT => Self::Text,
            ffi::PPS_ANNOTATION_TYPE_ATTACHMENT => Self::Attachment,
            ffi::PPS_ANNOTATION_TYPE_TEXT_MARKUP => Self::TextMarkup,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for AnnotationType {
    #[inline]
    #[doc(alias = "pps_annotation_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_annotation_type_get_type()) }
    }
}

impl glib::HasParamSpec for AnnotationType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for AnnotationType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AnnotationType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AnnotationType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AnnotationType> for glib::Value {
    #[inline]
    fn from(v: AnnotationType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsDocumentContainsJS")]
pub enum DocumentContainsJS {
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_UNKNOWN")]
    Unknown,
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_NO")]
    No,
    #[doc(alias = "PPS_DOCUMENT_CONTAINS_JS_YES")]
    Yes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DocumentContainsJS {
    type GlibType = ffi::PpsDocumentContainsJS;

    #[inline]
    fn into_glib(self) -> ffi::PpsDocumentContainsJS {
        match self {
            Self::Unknown => ffi::PPS_DOCUMENT_CONTAINS_JS_UNKNOWN,
            Self::No => ffi::PPS_DOCUMENT_CONTAINS_JS_NO,
            Self::Yes => ffi::PPS_DOCUMENT_CONTAINS_JS_YES,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsDocumentContainsJS> for DocumentContainsJS {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsDocumentContainsJS) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_DOCUMENT_CONTAINS_JS_UNKNOWN => Self::Unknown,
            ffi::PPS_DOCUMENT_CONTAINS_JS_NO => Self::No,
            ffi::PPS_DOCUMENT_CONTAINS_JS_YES => Self::Yes,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for DocumentContainsJS {
    #[inline]
    #[doc(alias = "pps_document_contains_js_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_document_contains_js_get_type()) }
    }
}

impl glib::HasParamSpec for DocumentContainsJS {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for DocumentContainsJS {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DocumentContainsJS {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DocumentContainsJS {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DocumentContainsJS> for glib::Value {
    #[inline]
    fn from(v: DocumentContainsJS) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsSelectionStyle")]
pub enum SelectionStyle {
    #[doc(alias = "PPS_SELECTION_STYLE_GLYPH")]
    Glyph,
    #[doc(alias = "PPS_SELECTION_STYLE_WORD")]
    Word,
    #[doc(alias = "PPS_SELECTION_STYLE_LINE")]
    Line,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SelectionStyle {
    type GlibType = ffi::PpsSelectionStyle;

    #[inline]
    fn into_glib(self) -> ffi::PpsSelectionStyle {
        match self {
            Self::Glyph => ffi::PPS_SELECTION_STYLE_GLYPH,
            Self::Word => ffi::PPS_SELECTION_STYLE_WORD,
            Self::Line => ffi::PPS_SELECTION_STYLE_LINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsSelectionStyle> for SelectionStyle {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsSelectionStyle) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_SELECTION_STYLE_GLYPH => Self::Glyph,
            ffi::PPS_SELECTION_STYLE_WORD => Self::Word,
            ffi::PPS_SELECTION_STYLE_LINE => Self::Line,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SelectionStyle {
    #[inline]
    #[doc(alias = "pps_selection_style_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_selection_style_get_type()) }
    }
}

impl glib::HasParamSpec for SelectionStyle {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SelectionStyle {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SelectionStyle {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SelectionStyle {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SelectionStyle> for glib::Value {
    #[inline]
    fn from(v: SelectionStyle) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectAlignment")]
pub enum TransitionEffectAlignment {
    #[doc(alias = "PPS_TRANSITION_ALIGNMENT_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "PPS_TRANSITION_ALIGNMENT_VERTICAL")]
    Vertical,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectAlignment {
    type GlibType = ffi::PpsTransitionEffectAlignment;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectAlignment {
        match self {
            Self::Horizontal => ffi::PPS_TRANSITION_ALIGNMENT_HORIZONTAL,
            Self::Vertical => ffi::PPS_TRANSITION_ALIGNMENT_VERTICAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectAlignment> for TransitionEffectAlignment {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectAlignment) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_ALIGNMENT_HORIZONTAL => Self::Horizontal,
            ffi::PPS_TRANSITION_ALIGNMENT_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectAlignment {
    #[inline]
    #[doc(alias = "pps_transition_effect_alignment_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_alignment_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectAlignment {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectAlignment {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectAlignment {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectAlignment {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectAlignment> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectAlignment) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectDirection")]
pub enum TransitionEffectDirection {
    #[doc(alias = "PPS_TRANSITION_DIRECTION_INWARD")]
    Inward,
    #[doc(alias = "PPS_TRANSITION_DIRECTION_OUTWARD")]
    Outward,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectDirection {
    type GlibType = ffi::PpsTransitionEffectDirection;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectDirection {
        match self {
            Self::Inward => ffi::PPS_TRANSITION_DIRECTION_INWARD,
            Self::Outward => ffi::PPS_TRANSITION_DIRECTION_OUTWARD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectDirection> for TransitionEffectDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_DIRECTION_INWARD => Self::Inward,
            ffi::PPS_TRANSITION_DIRECTION_OUTWARD => Self::Outward,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectDirection {
    #[inline]
    #[doc(alias = "pps_transition_effect_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_direction_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectDirection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectDirection> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PpsTransitionEffectType")]
pub enum TransitionEffectType {
    #[doc(alias = "PPS_TRANSITION_EFFECT_REPLACE")]
    Replace,
    #[doc(alias = "PPS_TRANSITION_EFFECT_SPLIT")]
    Split,
    #[doc(alias = "PPS_TRANSITION_EFFECT_BLINDS")]
    Blinds,
    #[doc(alias = "PPS_TRANSITION_EFFECT_BOX")]
    Box,
    #[doc(alias = "PPS_TRANSITION_EFFECT_WIPE")]
    Wipe,
    #[doc(alias = "PPS_TRANSITION_EFFECT_DISSOLVE")]
    Dissolve,
    #[doc(alias = "PPS_TRANSITION_EFFECT_GLITTER")]
    Glitter,
    #[doc(alias = "PPS_TRANSITION_EFFECT_FLY")]
    Fly,
    #[doc(alias = "PPS_TRANSITION_EFFECT_PUSH")]
    Push,
    #[doc(alias = "PPS_TRANSITION_EFFECT_COVER")]
    Cover,
    #[doc(alias = "PPS_TRANSITION_EFFECT_UNCOVER")]
    Uncover,
    #[doc(alias = "PPS_TRANSITION_EFFECT_FADE")]
    Fade,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TransitionEffectType {
    type GlibType = ffi::PpsTransitionEffectType;

    #[inline]
    fn into_glib(self) -> ffi::PpsTransitionEffectType {
        match self {
            Self::Replace => ffi::PPS_TRANSITION_EFFECT_REPLACE,
            Self::Split => ffi::PPS_TRANSITION_EFFECT_SPLIT,
            Self::Blinds => ffi::PPS_TRANSITION_EFFECT_BLINDS,
            Self::Box => ffi::PPS_TRANSITION_EFFECT_BOX,
            Self::Wipe => ffi::PPS_TRANSITION_EFFECT_WIPE,
            Self::Dissolve => ffi::PPS_TRANSITION_EFFECT_DISSOLVE,
            Self::Glitter => ffi::PPS_TRANSITION_EFFECT_GLITTER,
            Self::Fly => ffi::PPS_TRANSITION_EFFECT_FLY,
            Self::Push => ffi::PPS_TRANSITION_EFFECT_PUSH,
            Self::Cover => ffi::PPS_TRANSITION_EFFECT_COVER,
            Self::Uncover => ffi::PPS_TRANSITION_EFFECT_UNCOVER,
            Self::Fade => ffi::PPS_TRANSITION_EFFECT_FADE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::PpsTransitionEffectType> for TransitionEffectType {
    #[inline]
    unsafe fn from_glib(value: ffi::PpsTransitionEffectType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::PPS_TRANSITION_EFFECT_REPLACE => Self::Replace,
            ffi::PPS_TRANSITION_EFFECT_SPLIT => Self::Split,
            ffi::PPS_TRANSITION_EFFECT_BLINDS => Self::Blinds,
            ffi::PPS_TRANSITION_EFFECT_BOX => Self::Box,
            ffi::PPS_TRANSITION_EFFECT_WIPE => Self::Wipe,
            ffi::PPS_TRANSITION_EFFECT_DISSOLVE => Self::Dissolve,
            ffi::PPS_TRANSITION_EFFECT_GLITTER => Self::Glitter,
            ffi::PPS_TRANSITION_EFFECT_FLY => Self::Fly,
            ffi::PPS_TRANSITION_EFFECT_PUSH => Self::Push,
            ffi::PPS_TRANSITION_EFFECT_COVER => Self::Cover,
            ffi::PPS_TRANSITION_EFFECT_UNCOVER => Self::Uncover,
            ffi::PPS_TRANSITION_EFFECT_FADE => Self::Fade,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TransitionEffectType {
    #[inline]
    #[doc(alias = "pps_transition_effect_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::pps_transition_effect_type_get_type()) }
    }
}

impl glib::HasParamSpec for TransitionEffectType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TransitionEffectType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransitionEffectType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransitionEffectType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransitionEffectType> for glib::Value {
    #[inline]
    fn from(v: TransitionEffectType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
